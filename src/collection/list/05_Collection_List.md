# 5. Collection_List

- 리스트 추상화
    - `List` 란 순서가 있고 중복을 허용하는 컬렉션이다.
    - `MyArrayList` 와 `MyLinkedList` 의 공통 기능을 인터페이스로 뽑아서 추상화 하면 다형성을 활용한 이득을 얻을 수 있다. → `MyList` 를 만들어 공통 기능을 뽑을 수 있음
    - 이때 공통 기능은 `MyArrayList`와 `MyLinkedList`에서 `@Override` 어노테이션을 추가해야 오류가 생기지 않는다.
    - `MyArrayList`나 `MyLinkedList`를 의존하여 데이터를 처리하는 클래스가 있다고 가정했을때 둘 중 하나만 의존하면 해당 성능을 이유로 의존을 바꾸려면 해당 클래스의 내부 코드도 변경을 해야한다.
        - 그러나 `MyList` 인터페이스를 만든 후 의존하면 해당 클래스의 내부 코드를 변경할 필요 없이 서비스 로직 코드만 변경하면 된다.
        - 즉, 해당 클래스를 `컴파일 시점` 이 아닌 `서비스 로직`에서 런타임 시점에 지정할 수 있다.
        - 이 행위를 의존관계가 외부에서 주입하는 것 같다고 해서 `의존관계 주입` 이라고 한다. → Dependency Injection, 줄여서 DI, 의존성 주입이라고도 함.
    - 이때 `MyList`를 의존받지만 `MyArrayList`나 `MyLinkedList`를 생성한 후 해당 클래스에 주입을 하더라도 `MyList`의 자식이므로 가능하다.
        - 이렇게 생성자를 통해 의존관계 주입하는 것을 `생성자 의존관계 주입` 줄여서 `생성자 주입`이라고 한다.
        - 또한 위 클래스는 `MyArrayList`나 `MyLinkedList`를 직접 의존하는 것이 아닌 부모인 `MyList`를 주입받으므로 낭비하는 코드 없이 반복해서 사용이 가능하다.
- `ArrayList`와 `LinkedList`의 성능 비교
    - 추가, 삭제
        - 배열 리스트는 인덱스를 통해 추가나 삭제할 위치를 O(1)로 빠르게 찾지만, 추가나 삭제 이후에 데이터를 한칸씩 밀어야 한다. 이 부분이 O(n)으로 오래 걸린다.
        - 연결 리스트는 인덱스를 통해 추가나 삭제할 위치를 O(n)으로 느리게 찾지만, 실제 데이터의 추가는 간단한 참조 변경으로 O(1)로 빠르게 수행된다.
    - 앞에 추가, 삭제
        - 배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 데이터를 한칸씩 이동 O(n) → O(n)
        - 연결 리스트: 추가나 삭제할 위치는 찾는데 O(1), 노드를 변경하는데 O(1) → O(1)
    - 평균 추가, 삭제
        - 배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 인덱스 이후의 데이터를 한칸씩 이동 O(n/2) → O(n)
        - 연결 리스트: 추가나 삭제할 위치는 찾는데 O(n/2), 노드를 변경하는데 O(1) → O(n)
    - 뒤에 추가, 삭제
        - 배열 리스트: 추가나 삭제할 위치는 찾는데 O(1), 이동할 데이터 없음 → O(1)
        - 연결 리스트: 추가나 삭제할 위치는 찾는데 O(1), 노드를 변경하는데 O(1) → O(1)
            - 자바가 제공하는 `LinkedList`는 마지막 위치를 가지고 있다.
    - 인덱스 조회
        - 배열 리스트: 배열에 인덱스를 사용해서 값을 O(1)로 찾을 수 있음
        - 연결 리스트: 노드를 인덱스 수 만큼 이동해야함 O(n)
    - 검색
        - 배열 리스트: 데이터를 찾을 때 까지 배열을 순회 O(n)
        - 연결 리스트: 데이터를 찾을 때 까지 노드를 순회 O(n)
    - 참고
        - 자바의 배열 리스트는 이때 메모리 고속 복사를 사용하기 때문에 성능이 최적화된다.
        - 메모리 고속 복사는 시스템에 따라 성능이 다르기 때문에 정확한 계산은 어렵지만 대략 O(n/10) 정도로 추정 → 상수 제거하면 O(n)
            - 그러나 메모리 고속 복사라도 데이터가 아주 많으면 느려진다.
            - 메모리 고속 복사 : 시스템 레벨에서 빠르게 복사하는 방법 → `MyArrayList` 에서는 루프를 돌면서 하나하나 이동을 했지만 메모리 고속 복사를 하게 되면 `System.arraycopy()` 를 사용하여 빠르게 복사한다.
    - 시간 복잡도와 실제 성능
        - 이론적으로 `LinkedList` 의 중간 삽입 연산은 `ArrayList` 보다 빠를 수 있다. 그러나 실제 성능은 요소의 순차적 접근 속도, 메모리 할당 및 해제 비용, CPU 캐시 활용도 등 다양한 요소에 의해 영향을 받음.
            - 추가로 `ArrayList` 는 데이터를 한 칸씩 직접 이동하지 않고, 대신에 메모리 고속 복사를 사용
        - `ArrayList` 는 요소들이 메모리 상에서 연속적으로 위치하여 CPU 캐시 효율이 좋고, 메모리 접근 속도가 빠름
        - 반면, `LinkedList` 는 각 요소가 별도의 객체로 존재하고 다음 요소의 참조를 저장하기 때문에 CPU 캐시 효율이 떨어지고, 메모리 접근 속도가 상대적으로 느려질 수 있음
        - `ArrayList`의 경우`CAPACITY` 를 넘어서면 배열을 다시 만들고 복사하는 과정이 추가되지만 한번에 50%씩 늘어나고 많이 일어나지 않으므로 영향을 크게 미치지 않음.
        - 즉, 여러 요소들을 비교했을때 실제 사용 환경에서는 `ArrayList`가 `LinkedList` 보다 나은 성능을 제공할 확률이 높음.
    - 배열리스트 VS 연결리스트
        - 대부분의 경우 배열 리스트가 성능상 유리 → 실무에서는 주로 배열 리스트를 기본으로 사용
        - but, 데이터를 앞쪽에서 자주 추가하거나 삭제할 일이 있다면 연결 리스트를 고려할 수 있음.