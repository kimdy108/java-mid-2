# 3. Collection_ArrayList

- 배열의 특징 1 - 배열과 인덱스
    - 열과 같이 여러 데이터(자료)를 구조화해서 다루는 것을 자료 구조라고 한다.
    - 배열에서 자료를 찾을 때 인덱스(index)를 사용하면 매우 빠르게 자료를 찾을 수 있다.
        - 인덱스를 통한 입력, 변경, 조회의 경우 한번의 계산으로 자료의 위치를 찾을 수 있다.
        - 배열은 메모리상에 순서대로 붙어서 존재한다. → 인덱스가 2 인 자료를 찾으려면 `배열의 시작 참조(x100) + (자료의 크기(4byte) * 인덱스 위치(2)) = x108` 으로 찾으면 된다.
        - 공식 : `배열의 시작 참조 + (자료의 크기 * 인덱스 위치)`
            - `arr[0]: x100 + (4byte * 0): x100`
            - `arr[1]: x100 + (4byte * 1): x104`  …
        - 즉 인덱스를 통한 자료는 한번의 연산으로 쉽게 찾을 수 있다.
    - 배열의 검색
        - 배열에 들어있는 데이터를 검색할 때는 배열에 들어있는 데이터를 하나하나 비교해야한다.
        - 이때는 이전과 같이 인덱스를 사용해서 한번에 찾을 수 없다. 대신에 배열안에 들어있는 데이터를 하나하나 확인해야 한다. → 길이가 길수록 오래걸린다.
        - 배열의 순차 검색은 길이가 n이면 n만큼 연산이 된다.
- 빅오 표기법 (O)
    - 빅오(Big O) 표기법은 알고리즘의 성능을 분석할 때 사용하는 수학적 표현 방식
    - 알고리즘이 처리해야 할 데이터의 양이 증가할 때, 그 알고리즘이 얼마나 빠르게 실행되는지 나타낸다. → 여기서 중요한것은 정확한 시간이 아니라 데이터 양의 증가에 따른 성능의 변화 추세를 이해하는 것이다.
    - 빅오 표기법
        - O(1) - 상수 시간: 입력 데이터의 크기에 관계없이 알고리즘의 실행 시간이 일정한다.
            - 배열에서 인덱스를 사용하는 경우
        - O(n) - 선형 시간: 알고리즘의 실행 시간이 입력 데이터의 크기에 비례하여 증가한다.
            - 배열의 검색, 배열의 모든 요소를 순회하는 경우
        - O(n²) - 제곱 시간: 알고리즘의 실행 시간이 입력 데이터의 크기의 제곱에 비례하여 증가한다.
            - 보통 이중 루프를 사용하는 알고리즘에서 나타남
        - O(log n) - 로그 시간: 알고리즘의 실행 시간이 데이터 크기의 로그에 비례하여 증가한다.
            - 이진 탐색
        - O(n log n) - 선형 로그 시간
            - 많은 효율적인 정렬 알고리즘들
    - 빅오 표기법은 매우 큰 데이터를 입력한다고 가정하고, 데이터 양 증가에 따른 성능의 변화 추세를 비교하는데 사용한다. → 즉 정확한 성능을 측정하는 것이 목표가 아니라 매우 큰 데이터가 들어왔을 때의 대략적인 추세를 비교하는것이 목적.
    - 빅오 표기법 (최적, 최악, 평균)
        - 최적의 경우 : 배열의 첫번째 항목에서 바로 값을 찾으면 O(1)가 된다. → 인덱스를 이용하여 찾으면 항상 O(1) 이다.
        - 최악의 경우 : 마지막 항목에 있거나 항목이 없는 경우 전체 요소를 순회한다. 이 경우 O(n)이 된다.
        - 평균의 경우 : 균적으로 보면 보통 중간쯤 데이터를 발견하게 된다. 이 경우 O(n/2)가 되지만, 상수를 제외하고 표기하므로 O(n)이 된다.
- 배열의 특징 2 - 데이터 추가
    - 배열 추가
        - 첫번째에 추가 : 기존 데이터들을 모두 뒤로 미루고 맨 앞에 추가 → 빅오 성능 : O(n)
        - 중간에 추가 : 지정한 인덱스부터 모두 뒤로 미루고 해당 인덱스에 추가 → 빅오 성능 : O(n)
        - 마지막에 추가 : 기존 데이터 변경 없이 맨 마지막에 추가 → 빅오 성능 : O(1)
    - 배열의 한계
        - 배열은 크기를 정해놓고 사용해야한다. 즉 해당 범위보다 더 큰 인덱스에 추가해야한다면 에러가 발생한다.
- 배열리스트 구현
    - 배열의 단점
        - 배열의 길이를 동적으로 변경할 수 없다.
        - 데이터를 추가하기 불편하다 → 맨앞이나 중간인 경우 데이터를 뒤로 미루고 해당 위치에 추가해야한다.
    - 순서가 있고, 중복을 허용하는 자료 구조를 리스트라고 한다.
    - 배열과 리스트
        - 배열 : 순서 O, 중복 O, 크기 변경 X
        - 리스트 : 순서 O, 중복 O, 크기 변경 O
    - 배열리스트에서 데이터를 추가할 때 해당 크기보다 더 많은 데이터를 추가해야한다면 새로운 배열 (배열의 크기를 더 크게하여 복사) 한 후 데이터를 추가한다. → 이때 기존 배열은 이제 필요 없으므로 GC 된다.
    - 또한 구현 당시 Object로 되어있으므로 타입 안정성이 보장되지 않는다. → 다운캐스팅 시 에러 발생한다.
    - 이때 제네릭을 사용하면 타입안정성을 보장할 수 있다.
    - 배열 리스트 단점
        - 정확한 크기를 미리 알지 못하면 메모리가 낭비된다. 배열을 사용하므로 배열 뒷부분에 낭비되는 메모리가 있을 수 있다.
        - 데이터를 중간에 추가하거나 삭제할때 비 효율적이다. → 이 경우 해당 데이터들을 뒤로 미루거나 앞으로 땡겨야한다.
    - 배열 리스트 정리
        - 데이터 추가
            - 맨 마지막 : O(1)
            - 앞, 중간 : O(n)
        - 데이터 제거
            - 맨 마지막 : O(1)
            - 앞, 중간 : O(n)
        - 인덱스 조회 : O(1)
        - 데이터 검색 : O(n)