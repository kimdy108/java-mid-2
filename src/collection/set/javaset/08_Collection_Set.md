# 8. Collection_Set

- 자바에서 제공하는 `Set`
    - Collection 프레임워크 - Set
        - Collection(interface) → Set(interface) `공통` → HashSet → LinkedHashSet
        - Collection(interface) → Set(interface) `공통` → TreeSet
    - `Set` 인터페이스는 기본적으로 순서를 보장하지 않고 중복을 허용하지 않는 유일한 요소의 집합을 나타낸다.
    - HashSet
        - 구현 : 해시 자료 구조를 사용해서 요소를 저장
        - 순서 : 요소들은 특정한 순서 없이 저장 → 요소를 추가한 순서를 보장하지 않음
        - 시간복잡도 : 주요 연산(추가, 삭제, 검색)은 평균적으로 `O(1)` 시간 복잡도를 가짐
        - 용도 : 데이터의 유일성만 중요하고, 순서가 중요하지 않은 경우에 적합
    - LinkedHashSet → LinkedArrayList 처럼 이중연결리스트의 Node를 통해 순서를 유지한다.
        - 구현 : `HashSet` 에 연결 리스트를 추가해서 요소들의 순서를 유지
        - 순서 : 요소들은 추가된 순서대로 유지된다. 즉, 순서대로 조회 시 요소들이 추가된 순서대로 반환
        - 시간복잡도 : 주요 연산에 대해 평균 `O(1)` 시간 복잡도를 가짐
        - 용도 : 데이터의 유일성과 함께 삽입 순서를 유지해야 할 때 적합
        - 참고 : 순서 유지를 해야하므로 `HashSet` 보다 조금 더 무거움
    - TreeSet
        - 구현 : `TreeSet` 은 이진 탐색 트리를 개선한 레드-블랙 트리를 내부에서 사용
        - 순서 : 요소들은 정렬된 순서로 저장
        - 시간복잡도 : 주요 연산들은 `O(log n)` 의 시간 복잡도를 가짐 → `HashSet`보다는 느림
        - 용도 :  데이터들을 정렬된 순서로 유지하면서 집합의 특성을 유지해야 할 때 사용 → 3, 1, 2 순서로 추가해도 출력했을때 1,2,3 으로 출력됨.
        - 구성
            - 트리 구성을 하고 있고 `LinkedHashSet`처럼 노드를 가지고 있음
            - 다만, `LinkedHashSet`와 다르게 왼쪽, 오른쪽으로 구분하는데 자신을 기준으로 왼쪽 노드에는 본인보다 작은 데이터, 오른쪽은 본인보다 큰 데이터 이다.
        - 특징
            - 시간복잡도가 `O(log n)` 으로 `O(n)` 인 리스트의 검색보다는 빠르고, `O(1)인` 해시의 검색 보다는 느리다.
            - 계산시 절반을 날린다는 것이 핵심이다. → 나보다 큰 데이터를 찾으면 왼쪽을 날리면 되고 작은 데이터를 찾으려면 오른쪽을 날리면 된다. 즉, 데이터가 많으면 많을 수록 더 효과적이다.
        - 성능
            - `TreeSet`의 경우 1,3,5,10,15 를 순서대로 추가했을때 모두 자신보다 큰 데이터 이므로 항상 오른쪽에 저장된다. 이 경우 시간복잡도가 `O(n)` 으로 최악이 된다.
            - 위 상황의 개선으로 자바에서는 중간 값을 기준으로 다시 정렬하는데 `TreeSet`의 경우 레드-블랙 트리를 사용해서 균형을 지속해서 유지한다.
        - 순회
            - `TreeSet`의 순회의 경우 자신보다 왼쪽에 있는 데이터 즉, 자신보다 작은 데이터를 모두 출력한 후 자신보다 큰 데이터를 출력하게 한다. → 정렬된 순서대로 출력한다.